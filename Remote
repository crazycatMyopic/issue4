package dev.alcazaar.chessfx.domain.remote;

import dev.alcazaar.chessfx.domain.Player;
import dev.alcazaar.chessfx.util.Constants;
import org.ice4j.StunException;
import org.ice4j.Transport;
import org.ice4j.TransportAddress;
import org.ice4j.attribute.*;
import org.ice4j.message.Message;
import org.ice4j.message.MessageFactory;
import org.ice4j.message.Request;
import org.ice4j.security.LongTermCredential;
import org.ice4j.security.LongTermCredentialSession;
import org.ice4j.stack.StunStack;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.function.Consumer;

import static dev.alcazaar.chessfx.util.Constants.SEPARATOR;
import static dev.alcazaar.chessfx.util.Util.*;

public class Remote implements Beetle {
    public static final String REMOTE_SEPERATOR = "_";
    private static final String userName = "54a4def2c7002fcb39d4fce2";
    private static final String password = "B5IxYlYC7X3sGSiq";
public static final String relam = "metered.ca";
    public static final String nonce = "0000019af335aa8abb6845430d42e3c6f9b7179a73dd50f5b402110c7a9fd8e794224497c7345620";
    private final DatagramSocket socket;
    private final MessageIntegrityAttribute messageIntegrityAttribute;
    private final NonceAttribute nonceAttribute;
    private final UsernameAttribute usernameAttribute;
    private final RealmAttribute realmAttribute;
    private String publicAddress = "";
    private volatile boolean server = false;
    private int publicPort = 0;

    public Remote() {
        try {
            this.socket = new DatagramSocket();
            usernameAttribute = AttributeFactory.createUsernameAttribute(userName);
            realmAttribute = AttributeFactory.createRealmAttribute(relam.getBytes(StandardCharsets.UTF_8));
            nonceAttribute = AttributeFactory.createNonceAttribute(nonce.getBytes(StandardCharsets.UTF_8));
            messageIntegrityAttribute = AttributeFactory.createMessageIntegrityAttribute(userName);

        } catch (SocketException e) {
            throw new RuntimeException(e);
        }
    }

    public int getPublicPort() {
        return publicPort;
    }

    public String getPublicAddress() {
        return publicAddress;
    }

    private void sendRequest(Request request) {
        try {
            byte[] id = new byte[12];
            random.nextBytes(id);
            request.setTransactionID(id);
            request.putAttribute( AttributeFactory.createRequestedTransportAttribute(RequestedTransportAttribute.UDP));
            request.putAttribute(usernameAttribute);
            request.putAttribute(realmAttribute);
            request.putAttribute(nonceAttribute);
            request.putAttribute(messageIntegrityAttribute);
            StunStack stunStack = new StunStack();
            stunStack.getCredentialsManager().registerAuthority(new LongTermCredentialSession(new LongTermCredential(userName, password), relam.getBytes(StandardCharsets.UTF_8)));

            byte[] message = request.encode(stunStack);
            socket.send(new DatagramPacket(message, message.length, new InetSocketAddress(Constants.TURN_SERVER, Constants.TURN_PORT)));
        } catch (IOException | StunException e) {
            throw new RuntimeException(e);
        }
    }

    public void establishConnection() {
        send(REMOTE_SEPERATOR + encrypt(REMOTE_SEPERATOR + publicAddress + SEPARATOR + publicPort));
    }

    private void send(String message) {
        try {
            byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);
//            socket.send(new DatagramPacket(messageBytes, messageBytes.length, new InetSocketAddress(publicAddress, publicPort)));
            socket.send(new DatagramPacket(messageBytes, messageBytes.length, new InetSocketAddress(Constants.TURN_SERVER, Constants.TURN_PORT)));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private Message receivePacket() {
        try {
            DatagramPacket packet = receive();
            return Message.decode(new byte[2024], 0, packet.getLength());
        } catch (StunException e) {
            throw new RuntimeException(e);
        }
    }

    private String receiveSimpleMessage() {
        DatagramPacket packet = receive();
        String message = new String(packet.getData(), 0, packet.getLength(), StandardCharsets.UTF_8);
        System.out.println("Received: " + message);
        return message;
    }

    private DatagramPacket receive() {
        try {
            byte[] buffer = new byte[3000];
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
            socket.receive(packet);
            return packet;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void server() {
        server = true;
    }

    private static final Random random = new Random();

    public void establishPermission(String ip, int port){
        Request request = MessageFactory.createCreatePermissionRequest(new TransportAddress(ip, port, Transport.UDP)
                , UUID.randomUUID().toString().getBytes(StandardCharsets.UTF_8));
        sendRequest(request);
        Message response = receivePacket();
        System.out.println(response.getName());

    }

    public void setAddress() {
        Request request = MessageFactory.createAllocateRequest();
        sendRequest(request);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        Message response = receivePacket();
        System.out.println(response);
        System.out.println(response.getName());
        XorRelayedAddressAttribute addressAttribute = (XorRelayedAddressAttribute) response.getAttribute(Attribute.XOR_RELAYED_ADDRESS);
        publicAddress = addressAttribute.getAddress().getHostAddress();
        publicPort = addressAttribute.getAddress().getPort();
    }

    @Override
    public Player getPlayer() {
        return Player.FRIEND;
    }

    @Override
    public void sync(Map<String, Object> settings) {
        try {
            // only server sends the settings
            if (server)
                send(mapper.writeValueAsString(settings));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void close() {
        socket.close();
        publicAddress = "";
        publicPort = 0;
    }

    @Override
    public void restart() {
        send(Constants.RESTART);
    }

    @Override
    public void move(String move) {
        send(move);
    }

    @Override
    public void set(Consumer<String> onDataReceived) {
        new Thread(() -> {
            while (true) {
                String message = receiveSimpleMessage();
                if (message.startsWith(REMOTE_SEPERATOR)) {
                    String[] parts = message.split(SEPARATOR);
                    if (parts.length == 2) {
                        server();
                        establishPermission(decrypt(parts[0]), Integer.parseInt(decrypt(parts[1])));
                    }
                } else
                    onDataReceived.accept(message);
            }
        }).start();
    }

    @Override
    public boolean isConnected() {
        return false;
    }

    @Override
    public void reConnect() {

    }

    @Override
    public void resign() {
        send(Constants.RESIGN);
    }
}
